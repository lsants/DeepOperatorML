# High Performance Numeric Integration

### Description

This project aims to develop a fast and high-performance method for integrating influence functions. The set of functions explored by this method frequently appear in various physical and engineering problems. Problems of this nature with unbounded domains are usually solved with the Boundary Element Method (BEM), which requires computing influence functions through integration at a significant number of points.

Traditional numerical integration techniques often struggle with these functions due to their complex nature, including singularities and improper integrals extending to infinity. By leveraging the field of operator learning and utilizing Deep Operator Networks (DeepONets), this project seeks to learn the underlying mathematical operators governing these problems, providing a more efficient and accurate integration approach that should reduce the overall cost of methods such as BEM.

### Project Overview

- **Goal**: To create a high-performance integration method for complex functions common in physical and engineering contexts, particularly those involving improper integrals with singularities and infinite upper limits.

- **Approach**: Utilize operator learning through DeepONets to model and learn the underlying mathematical operators that define the problem, enabling faster and more efficient computation.

- **Problem Statement**: Compute influence functions that describe the response of an isotropic half-space to a line load applied at a plane at the origin. These influence functions are computationally expensive to calculate due to the nature of the integrals involved.
  
- **Implementation**: The model is developed in Python using PyTorch's deep learning API.

---

## Repository Structure

The repository is organized as follows:
```
ðŸ“¦ 
â”œâ”€Â .gitignore
â”œâ”€Â README.md
â”œâ”€Â comparison_plot.py
â”œâ”€Â data_generation
â”‚Â Â â”œâ”€Â axsgrsce.dll
â”‚Â Â â”œâ”€Â axsgrsce.dylib
â”‚Â Â â”œâ”€Â axsgrsce.so
â”‚Â Â â”œâ”€Â data_generation_base.py
â”‚Â Â â”œâ”€Â data_generation_dimless_green.py
â”‚Â Â â””â”€Â influence.py
â”œâ”€Â data_generation_params.yaml
â”œâ”€Â get_data.py
â”œâ”€Â modules
â”‚Â Â â”œâ”€Â compose_transformations.py
â”‚Â Â â”œâ”€Â dataset_preprocessing.py
â”‚Â Â â”œâ”€Â evaluate_params.py
â”‚Â Â â”œâ”€Â greenfunc_dataset.py
â”‚Â Â â”œâ”€Â loss_complex.py
â”‚Â Â â”œâ”€Â mlp.py
â”‚Â Â â”œâ”€Â model_evaluator.py
â”‚Â Â â”œâ”€Â plotting.py
â”‚Â Â â”œâ”€Â preprocessing.py
â”‚Â Â â”œâ”€Â saving.py
â”‚Â Â â”œâ”€Â training.py
â”‚Â Â â””â”€Â vanilla_deeponet.py
â”œâ”€Â params_model.yaml
â”œâ”€Â plot_labels.py
â”œâ”€Â plot_preds.py
â”œâ”€Â requirements.txt
â”œâ”€Â test_model.py
â””â”€Â train_model.py
```

## Data generation

The data for training the DeepOnet can be generated by defining the boundary value problem's parameters in the ```data_generation_params.yaml``` file and running the ```get_data.py``` script.


## DeepONet trainning

To train the deep learning model, define the model and training parameters in the ```params_model.yaml``` file and run the ```train_model.py``` script.

## Comparing displacement fields

Run the ```comparison_plot.py``` to visualize the prediction of the test dataset and compare it with the generated data.